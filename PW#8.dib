#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №8. Реализация планировщика команд.

**Цель:** Реализация длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Сделать возможным в потоке выполнять длительные операции.

## Задание.
Пусть, в условиях практической работы №7, у нас есть поток с очередью, который в цикле извлекает команды из очереди и выполняет их.

Некоторые из команд не могут выполнить всю работу за один вызов метода Execute без блокирования на длительное время выполнения всех остальных команд из очереди.

Например, если какая-нибудь сетевая игра представлена командой, то пока одна игра не закончится, следующая не начнется. Чтобы эффективнее использовать процессорные
мощности, нужно обеспечить возможность поиграть как можно большему количеству игроков.

Для этого используют режим псевдопараллельной обработки. Когда все время работы разбивают на небольшие отрезки, каждый из которых выполняется
за один вызов метода Execute. Чтобы выполнить всю работу, нужно вызвать метод Execute несколько раз, до тех пор пока работа не будет завершена.
Это позволяет между вызовами Execute одного экземплыра команды вызывать метод Execute других команд.

Так устроен, например, ренедринг страницы в браузере. Только в браузеоре это используется не для рендеренга всех вкладок, а для обработки 
реакций пользователя на странице.

В прошлой работе все команды, которые выполнялись в потоке, брались из очереди. Поэтому первая идея - это положить долгоиграющую операцию обратно в очередь.
Но это может привести к состоянию мертвой блокировки потока: если очередь будет полна, то поток, который попытается сделать запись, будет заблокирован до тех пор, 
пока в очереди не появится свободное место. Поэтому нельзя в одном и том же потоке читать и писать в очередь неблокируемым образом.

Чтобы избежать мертвой блокировки потока, необходимо ввести понятие Планировщика, который будет отвечать за выбор следующей длительной задачи для выполнения,
а чтение из очереди оставить только для новых операций. 

#!markdown

Необходимо реализовать поток, который способен реализовывать длительные операции.

**Указание.** 
1. В практической работе №7 из очереди команды извлекались блокируеммым образом с помощью метода Take(), при наличии планировщика так делать нельзя: поток
может заснуть несмотря на наличие команд в планировщике до тех пор, пока не будет записана новая команда в очередь.

С другой стороны, если будем всегда читать неблокируемым образом, а в планировщике нет никакой работы, то будем тратить процессорное время без полезной нагрузки.

Необходимо учесть этот момент при реализации очереди.

2. Для обепечения справедливости стратегии планировщика в слабом смысле использовать стратегию Round Robbin (циклическую) для определения следующего потока на исполнение.

#!csharp

using System.Threading;
using System.Collections.Concurrent;
public interface ICommand
{
    void Execute();
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

public interface ILongCommand: ICommand{
    bool IsDone();
}

#!csharp

class LongCommand: ILongCommand
{
    public int remain_use;
    public bool Done = false;
    public LongCommand(int use){
        this.remain_use = use;
    }
    public void Execute(){
        Console.WriteLine("long command remain: " + remain_use);
        this.remain_use--;
        Done = this.remain_use == 0 ? true : false;
    }
    public bool IsDone(){
        return Done;
    }
}

#!csharp

class Scheduler: IScheduler
{
    protected ConcurrentQueue<ICommand> queue = new ConcurrentQueue<ICommand>(); 
    protected ConcurrentQueue<ILongCommand> queue_for_long = new ConcurrentQueue<ILongCommand>(); 

    public bool HasCommand(){
        return !queue.IsEmpty;
    }
    public bool HasLongCommand(){
        return !queue_for_long.IsEmpty;
    }
    public ICommand Select(){
        ICommand command; queue.TryDequeue(out command);
        return command;
    }
    public void Add(ICommand cmd){
        if (cmd is ILongCommand long_command) { queue_for_long.Enqueue(long_command); }
        else { queue.Enqueue(cmd); }
    }
    public ILongCommand RunLong(){
        queue_for_long.TryDequeue(out ILongCommand command);
        command.Execute();
        return command;
    }
    public bool IsCommDone(){
        queue_for_long.TryPeek(out ILongCommand command);
        return command.IsDone();
    }
}

#!csharp

class ServerThread
{
    protected ConcurrentQueue<ICommand> cqueue = new ConcurrentQueue<ICommand>();
    protected Thread server_thread; volatile bool not_stopped_hard = true, not_stopped_soft = true, not_stopped_exactly = true;
    private Scheduler scheduler = new Scheduler();public Thread name_of_thread = Thread.CurrentThread;

    public void Add_New_Commands(ICommand command){
        scheduler.Add(command);
    }
    public void Add_New_Thread(ICommand some_thread){
        cqueue.Enqueue(some_thread);
    }
    public int Get_Server_Thread(){
        return name_of_thread.GetHashCode();
    }
    public void Demand_Hard(){
        not_stopped_hard = false;
    }
    public void Demand_Stop(){
        not_stopped_exactly = false;
    }
    public void Demand_Soft(){
        not_stopped_soft = false;
    }
    public void Run_Thread(){
        while (not_stopped_exactly && not_stopped_hard)
        {
            if (scheduler.HasCommand() || scheduler.HasLongCommand()) {
                if (scheduler.HasCommand())
                {var now_command = scheduler.Select(); 
                Console.WriteLine("simple comm");
                    now_command.Execute();}
                else {
                    Console.WriteLine("not simple");
                    ILongCommand comm = scheduler.RunLong(); 
                    if (!comm.IsDone()) { Add_New_Commands(comm);}}
            }
            else {not_stopped_exactly = false;}
            if (!not_stopped_soft && !scheduler.HasCommand() && !scheduler.HasLongCommand() ) {Console.WriteLine("stop softly"); return;}
        }Console.WriteLine("thread stop hardly or exactly");
    }
    public void Start_Thread(){
        this.server_thread.Start();
    }
    public void Stop_Thread(){
        this.server_thread.Join(); Demand_Stop();
    }
    public ConcurrentQueue<ICommand> Get_Queue(){
        return cqueue;
    }
}

#!csharp

class ExceptionHandler{
    public static void Ex_Handler(string command, Exception exception){
        throw new Exception(exception.Message + " from " + command);
    }
}

#!csharp

class HardStop: ICommand
{
    protected ServerThread s_thread;
    public HardStop(ServerThread thread){
        this.s_thread = thread;
    }
    public void Execute(){
        int current_t = Thread.CurrentThread.GetHashCode();
        if (Thread.CurrentThread.GetHashCode() == s_thread.Get_Server_Thread()) {ExceptionHandler.Ex_Handler("HardStop", new InvalidOperationException("Non-server thread"));}
        s_thread.Demand_Hard();
    }
}

#!csharp

class SoftStop: ICommand 
{
    protected ServerThread s_thread;
    public SoftStop(ServerThread thread){
        this.s_thread = thread;
    }
    public void Execute(){
        var current_t = Thread.CurrentThread.GetHashCode();
        if (Thread.CurrentThread.GetHashCode() == s_thread.Get_Server_Thread()) {ExceptionHandler.Ex_Handler("SoftStop", new InvalidOperationException("Non-server thread"));}
        s_thread.Demand_Soft();
    }
}

#!csharp

ServerThread program = new ServerThread();
program.Add_New_Commands(new HardStop(program));
program.Add_New_Commands(new LongCommand(5));
Thread myThread = new Thread(program.Run_Thread);
myThread.Start();
myThread.Join();

Console.WriteLine();

program = new ServerThread();
program.Add_New_Commands(new SoftStop(program));
program.Add_New_Commands(new LongCommand(3));
myThread = new Thread(program.Run_Thread);
myThread.Start();
myThread.Join();
