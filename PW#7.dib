#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

class ExceptionHandler{
    public static void Ex_Handler(ICommand command, Exception exception){
        throw new Exception(exception.Message + " from " + command.GetType().Name);
    }
}

#!csharp

using System.Threading;
using System.Collections.Concurrent;
class ServerThread
{
    protected ConcurrentQueue<ICommand> cqueue = new ConcurrentQueue<ICommand>();
    protected Thread server_thread; volatile bool not_stopped_hard, not_stopped_soft, not_stopped_exactly = true;
    public ServerThread(){
        this.server_thread = new Thread(() => Run_Thread());
    }
    public void Add_New_Thread(ICommand some_thread){
        cqueue.Enqueue(some_thread);
    }
    public Thread Get_Server_Thread(){
        return this.server_thread;
    }
    public void Demand_Hard(){
        not_stopped_hard = false;
    }
    public void Demand_Stop(){
        not_stopped_exactly = false;
    }
    public void Demand_Soft(){
        not_stopped_soft = false;
    }
    public void Run_Thread(){
        while (not_stopped_exactly && not_stopped_hard)
        {
            if (not_stopped_soft && cqueue.IsEmpty) { not_stopped_exactly = false; continue; }
            if (cqueue.TryDequeue(out ICommand comm_hard_or_soft)){
                try { comm_hard_or_soft.Execute(); } catch (Exception exception) { ExceptionHandler.Ex_Handler(comm_hard_or_soft, exception); }
            }
        }
    }
    public void Start_Thread(){
        this.server_thread.Start();
    }
    public void Stop_Thread(){
        this.server_thread.Join(); Demand_Stop();
    }
    public ConcurrentQueue<ICommand> Get_Queue(){
        return cqueue;
    }
}

#!csharp

class HardStop: ICommand
{
    protected ServerThread s_thread; 
    public HardStop(ServerThread thread){
        this.s_thread = thread;
    }
    public void Execute(){
        var queue = s_thread.Get_Queue();
        Thread current_t = Thread.CurrentThread;
        ICommand res; queue.TryPeek(out res);
        if (this.s_thread.Get_Server_Thread() != current_t) {ExceptionHandler.Ex_Handler(res, new InvalidOperationException("Non-server thread"));}
        s_thread.Demand_Hard();
    }
}

#!csharp

class SoftStop: ICommand 
{
    protected ServerThread s_thread;
    public SoftStop(ServerThread thread){
        this.s_thread = thread;
    }
    public void Execute(){
        Thread current_t = Thread.CurrentThread;
        ICommand res;
        var queue = s_thread.Get_Queue(); queue.TryPeek(out res);
        if (this.s_thread.Get_Server_Thread() != current_t) {ExceptionHandler.Ex_Handler(res, new InvalidOperationException("Non-server thread"));}
        s_thread.Demand_Soft();
    }
}

#!csharp

var s_Thread = new ServerThread();
try {
    s_Thread.Start_Thread();
    s_Thread.Add_New_Thread(new SoftStop(s_Thread));
    s_Thread.Stop_Thread();

    s_Thread = new ServerThread();
    s_Thread.Start_Thread();
    s_Thread.Add_New_Thread(new HardStop(s_Thread));
    s_Thread.Stop_Thread();
    // ожидается отстутсвие исключений
}
catch (Exception e){
    Console.WriteLine(e.Message);
}
// попытка остановить не серверный поток
var otherThread = new Thread(() =>
{
    SoftStop soft = new SoftStop(s_Thread); 
    try
    {
        soft.Execute();
    }
    catch (Exception ex)
    {
        Console.WriteLine("Catch exception: " + ex.Message);
    }
});
otherThread.Start();
otherThread.Join();
otherThread = new Thread(() =>
{
    HardStop hard = new HardStop(s_Thread);
    try
    {
        hard.Execute();
    }
    catch (Exception ex)
    {
        Console.WriteLine("Catch exception: " + ex.Message);
    }
});
otherThread.Start();
otherThread.Join();
